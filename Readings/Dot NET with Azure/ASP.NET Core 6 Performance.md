
# Caching Techniques

## ### Distributed Caching with Expiration

- use a distributed cache instead of an in‑memory one
- The first thing we need to do is update our constructor to inject an IDistributedCache instance
	- using the interface instead of using a direct implementation of ours, we'll have flexibility in choosing whatever store we want for our distributed cache
- First, check the cache to see if the results we want exist in it, and if so, use those results. If not, get the data from the database, put them in the distributed cache, and return the results we got. As I call the GetAsync method on the distributed cache with the same cache key, though, note what it's going to return to us, a byte array. Since we're using some external store for the cache data, and that external store could be any number of different things, a byte array was chosen to accommodate the possible variety of destinations. This means that we'll need to be able to serialize and deserialize our cached content to byte arrays when working with a distributed cache. For now, let's work the case where we didn't find anything in the cache so our results are null, and we need to get them from the database. I'll paste in the database logic from the memory caching block above, and I'll change the captured variable to a local variable of products that we'll need to serialize. And if we have determined that we really do want to cache these particular results, we know that we're already concerned with performance, so we're going to want to make our serialization logic as fast as we can, too. Remember what we saw in the last module? Yep, source generators, with System.Text.Json. This serialization is on our ProductEntity class rather than the ProductModel that we worked with earlier, so I added a new SourceGenerationContext class here. It inherits from JsonSerializerContext and uses an attribute to indicate that it can handle lists of products. Since I'll use this technique for both serialization and deserialization, I don't need to indicate any special case handling here. But with that class in place, we can use a JsonSerializer to serialize our product results. We pass in those results and the CacheSourceGenerationContext class, its default instance, and the list of products that we set up. That's a serialized JSON string, but we need a byte array. So when we set this content into the cache, we can use the Encoding.UTF8.GetBytes method on this string to be what we actually cache. And when we put something into the cache, we need to specify how long we want it to stick around, and possibly some other options. For simplicity's sake, I'm just going to use the absolute expiration from now option and keep our cached data for 10 minutes. And now we want to return some results to the caller of the method. To avoid deserializing the results we just got and serialized, we can return the productsToSerialize variable that we set with the results of our database query. And now we need to handle the situation where we actually found the results in our cache. Remember, this is a byte array, so we need to deserialize it using the reverse technique from what we just did above. We can do this in a single line by using the JsonSerializer to deserialize not the disk results byte array, but the Encoding.UTF8.GetString of that byte array. Again, we use the CacheSourceGenerationContext with the list of products to take advantage of our source generator. I'll return these results coalesced with an empty list, and the IDE is complaining that I've got two variables for results. We don't need both in‑memory and distributed caching here, so I'll comment out our in‑memory black. This logic should work just fine regardless of what we choose to use for a distributed cache. We just need to provide an implementation during our app startup. Let's do that and validate our code in the next clip.